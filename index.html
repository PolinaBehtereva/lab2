
<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<!-- Название презентации -->
		<title>Математическая статистика</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<!-- Тема презентации -->
		<link rel="stylesheet" href="dist/theme/moon.css" id="theme">
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin="" />
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">

		<style>
			h1{
				font-size: 2.77em !important;
			}
			/* Чтобы поля ввода были такого же размера, как и текст, увеличим размер шрифта дополнительно */
			input, select {
				font-size: 25px;
			}
			/* Чтобы тригонометрическая таблица влезла опытным путем уменьшим размер на 30%*/
			#table {
				font-size: 70%;
			}
			/* Для невидимых элементов создадим скрывающий класс */
			.hide {
				display: none;
			}
			/* Высоту карты задаем обязательно, опытным путем определили высоту в 350 пикселей */
			.map {
				height: 350px;
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<!-- Все слайды размечаем внутри slides -->
			<div class="slides">

				<!-- 
					Слайд заголовок
					Используем 1 заголовок 
					Так как используется markdown прописываем дополнительно аттрибутами 
						data-markdown data-separator-notes="^Note:"
						а так же помещаем markdown разметку внутрь <script type="text/template"></script>
					Для заметок используем конструкцию Note: новая строка
					Для центрирования по вертикали используйте класс center
				-->
				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						Математическая 
						==========
						статистика
						==========

				
						Note:
						Заголовок
					</script>
				</section>

				<!-- В слайдах разделителях используем 2 заголовок -->
				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						Определения и примеры
						-----------

					</script>
				</section>

				<!-- 
					В обычных слайдах используем 3 заголовок
					Греческие буквы можно набирать с помощью греческой раскладки клавиатуры или 
					простым копированием с эталонного алфавита
				 -->
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Математическая статистика

						***Математическая статистика*** - раздел математики, разрабатывающий методы регистрации, описания
						и анализа данных наблюдений и экспериментов с целью построения вероятностных моделей массовых случайных явлений.
				
						Note:
						
					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Выборка
						<!-- Последовательность независимых случайных величин $x_1, x_2,...,x_n,$ 
						соответствующих всем возможным результатам $n$ статистических экспериментов и имеющих одинаковый закон 
						распределения вероятностей со случайной величиной ξ, 
						называется *выборкой* или *выборочной совокупностью* объёма $n$, порождённой случайной величиной ξ. -->
						***Выборка*** или ***выборочная совокупность*** - это часть объектов из генеральной совокупности, 
						отобранных для сплошного изучения.

						***Генеральной совокупностью*** называется совокупность объектов подлежащих изучению по отношению к некторому
						качественному или количественному признаку. 
				
						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Примеры выборки

						**Пример 1:** В высокий цилиндрический сосуд с жидкостью сбрасывается достаточно маленький и тяжёлый шарик, 
						после чего замеряется время его погружения.				
						Предположим, что в результате 5 опытов получены следующие результаты (в секундах):		
						$t_1 = 6.9, t_2 = 6.7,  t_3 = 7,  t_4 = 7.2,  t_5 = 6.8$
						Таким образом, проведённые 5 опытов есть, по сути, выборка. Т.к. шарик можно было сбрасывать в воду гораздо большее и 
						теоретически вообще бесконечное количество раз. 

						Note:
						
					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Примеры выборки

						**Пример 2:** Иннокентий пошёл на базу исследовать помидоры. Ему требуется определить среднюю массу помидора. Очевидно, что на базе находится много помидоров. И для того, чтобы посчитать среднюю массу помидора, можно взвесить каждый овощ по отдельности
						и посчитать их среднее арифметическое. Но это долго и трудно. Поэтому для оценки можно собрать минимум 500-1000 помидоров, которые будут 
						характеризовать всю совокупность помидоров. Это количество помидоров и будет считаться выборкой.


						Note:
						
					</script>
				</section>

				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Выборочное среднее

						***Выборочным средним ($\bar x_в$)*** называется среднее арифметическое значений признака выборочной совокупности.

						Для различных значений $x_1, x_2,...,x_n$  признака выборочной совокупности объема $n$ имеем:

						
						$\bar x_в$ = $\tfrac{x_1 + x_2 +...+ x_n}{n}$ = $\tfrac{\sum\limits_{i=1}^{n} x_i}{n}$

						Note:

					</script>
				</section>

				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Выборочное среднее
						
						Если значения признака имеют соответствующие частоты $n_1+n_2+…+n_k = n$, то 

						$\bar x_в$ = $\tfrac{x_1n_1 + x_2n_2 +...+ x_kn_k}{n}$ = $\tfrac{\sum\limits_{i=1}^{k} x_in_i}{n}$

						Note:

					</script>
				</section>

				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Примеры выборочного среднего
						**Для дискретного вариационного ряда:** Пусть дана выборка с соответсвующими ей частотами, где $x$ - размер обуви<br>
						$x: 35, 36, 37, 38, 39, 40, 41, 42$<br>
						$n_i: 8, 9, 8, 12, 24, 25, 5, 9$<br>
						Тогда: $n$ = 8 + 9 + 8 + 12 + 24 + 25 + 5 + 9 = 100<br>
						<br>$\bar x_в$ <!-- = $\tfrac{\sum\limits_{i=1}^{8} x_i n_i}{100}$ --> = $\tfrac{35\cdot 8 + 36\cdot9 + 37\cdot8 + 38\cdot12 + 39\cdot24 + 40\cdot25 + 41\cdot5 + 42\cdot9}{100}$ = 38.75

						Note:

					</script>
				</section>

				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Примеры выборочного среднего
						**Для интервального вариационного ряда:** Пусть даны интервалы с соответсвующими им частотами.<br>
						$x:[80;90), [90;100), [100;110), [110;120), [120;130)$<br>
						$n_i: 8, 15, 36, 29, 12$<br>
						<br>$\bar x_в$ = $\tfrac{85\cdot8 + 95\cdot15 + 105\cdot36 + 115\cdot29 + 125\cdot12}{100}$
						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Медиана

						***Медианой ($M_e$)*** называется значение признака приходящаяся на середину ранжированного(упорядоченного) ряда наблюдений.		
						- Если вариационный ряд имеет нечетное число членов($n = 2m + 1$), то $M_e$ = $x_{m+1}$		
						- Если число членов ряда чётно($n = 2m$), то <br> $M_e$ = $\frac{x_m + x_{m+1}}{2}$
						

						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Медиана

						- Формула нахождения медианы для интервального ряда:<br>  $M_e$ = $x_{M_e}$ + $h\cdot\tfrac{\tfrac{n}{2} - n_{M_e}^\text{нак}}{n_{M_e-1}}$ ,где<br>  
						$x_{M_e}$ - начало медианного интервала<br>
						$n_{M_e}$ - частота медианного интервала<br>
						$n_{M_e-1}^\text{нак}$ - накопленная частота предмедианного интервала<br>
						$h$ - ширина интервала


						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Примеры медиан
						***Для дискретного ряда:*** Пусть дана выборка с соответсвующими ей частотами, где $x$ - размер обуви<br>
						$x: 35, 36, 37, 38, 39, 40, 41, 42$<br>
						$n_i: 8, 9, 8, 12, 24, 25, 5, 9$<br>
						<br>$M_e$ = $\tfrac{x_{50} + x_{51}}{2}$ = $\tfrac{39 + 39}{2}$ = 39


						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Примеры медиан
						***Для интервального ряда:*** Пусть даны интервалы с соответсвующими им частотами.<br>
						$x:[80;90), [90;100), [100;110), [110;120), [120;130)$<br>
						$n_i: 8, 15, 36, 29, 12$<br>
						<br>$M_e$ = 100 + $10\cdot\tfrac{\tfrac{100}{2} - 23}{36}$ = 107.5


						Note:

					</script>
				</section>

				

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Мода
						
						***Мода ($M_o$)*** - значение во множестве наблюдений, которое встречается наиболее часто. То есть, вариант, которому 
						соответствует наибольшая частота.

						Иногда в совокупности встречается более чем одна мода.  
						 
						**Например:** 6, 2, 6, 6, 8, 9, 9, 9, 0; мода — 6 и 9    
						В этом случае можно сказать, что совокупность мультимодальна. 

						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Мода
						
						Для интервального ряда находят модальный интервал:<br>
						<br>$M_o$ = $x_{M_o}$ + $h\cdot\tfrac{n_{M_o} - n_{M_o-1}}{(n_{M_o}-n_{M_o-1}) + (n_{M_o}-n_{M_o+1})},$<br>
						<br>где $x_{M_o}$ - начало интервала, где содержится $n_{M_o}$;<br>
						$n_{M_o}$ - наибольшая частота

						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Пример моды
						**Для интервального ряда:** Пусть даны интервалы с соответсвующими им частотами.<br>
						$x:[80;90), [90;100), [100;110), [110;120), [120;130)$<br>
						$n_i: 8, 15, 36, 29, 12$<br>
						<br>$M_o$ = 100 + $10\cdot\tfrac{36 - 15}{(36 -15) + (36 -29)}$ = 107.5

						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Минимум
						


						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Максимум
						


						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Размах
						
						***Размах ($R$)*** - разность между наибольшим и наименьшим значениями результатов наблюдений.<br><br>
						**Пример:** Дана выборка суммы денег, потраченных в каждый из шести дней.<br>
						$x_1 = 150, x_2 = 180, x_3 = 230, x_4 = 250,$<br>$ x_5 = 160, x_6 = 170$<br>В этом случае  
						$x_\text{max}$ = 250 ,$x_\text{min}$ = 150 <br>
						$R$ = $x_\text{max} - x_\text{min}$ = 250 - 150 = 100

						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Дисперсия
						***Дисперсия или выборочная дисперсия ($D_в$)***  – это среднее арифметическое квадратов отклонений всех вариант выборки от выборочной средней<br>
						$D_в$ = $\tfrac{\sum\limits_{i=1}^{n}(x_i - \bar x_в)^2}{n}$<br>
						Для несформированного вариационного ряда: <br>
						$D_в$ = $\tfrac{\sum\limits_{i=1}^{n}(x_i - \bar x_в)^2\cdot n_i}{n}$,<br>
						где $n_i$ - соответствующие частоты;
						$x_i$ - одинаковые по значению варианты.

						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Нормальное распределение
						***Нормальное распределение ($N(a,σ)$)*** - распределение вероятностей, которое в одномерном случае задается 
						функцией плотности вероятности, совпадающей с функцией Гаусса:<br>
						$f(x)$ = $\tfrac{1}{σ\cdot\sqrt{2\pi}}\cdot e^{\tfrac{-(x-a)^2}{2\cdotσ^2}}$,<br>
						где $a$ - математическое ожидание, медиана и мода;
						$σ$ - среднеквадратическое отклонение;<br>
						$σ^2$ - дисперсия распределения.

						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Нормальное распределение
						**Пример нормального распределения:**
						Нормально распределенная случайная величина задана параметрами $a$ = 3, $σ$ = 2. Записать её функцию плотности.
						В данном случае<br>
						$f(x)$ = $\tfrac{1}{2\cdot\sqrt{2\pi}}\cdot e^{\tfrac{-(x-3)^2}{2\cdot2^2}}$ = 
						$\tfrac{1}{2\cdot\sqrt{2\pi}}\cdot e^{\tfrac{-(x-3)^2}{8}}$

						Note:

					</script>
				</section>


				<!-- 
					Для вставки формул используйте конструкции $$ $$ или $ $
					Греческие буквы можно также набрать с помощью TeX
				 -->
				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Широта

						Широта - угол $\phi$ между местным направлением зенита
						и плоскостью экватора, отчитываемый от $0^\circ$ до $90^\circ$
						в обе стороны от экватора. Географическую широту точек
						лежащих в северном полушарии, принято считать положительной,
						широту в южном полушарии отрицательной. 
						
						Note:
						Широта - угол фи между местным направлением зенита
						и плоскостью экватора, отчитываемый от 0 градусов до 90 градусов
						в обе стороны от экватора. Географическую широту точек
						лежащих в северном полушарии, принято считать положительной,
						широту в южном полушарии отрицательной. 

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Широта

						Из-за отличия формы Земли от шара, географическая
						широта точек несколько отличается от их геоцентрической
						широты, то есть угла между направлением на данную точку
						из центра Земли и плоскостью экватора.
						
						Note:
						Из-за отличия формы Земли от шара, географическая
						широта точек несколько отличается от их геоцентрической
						широты, то есть угла между направлением на данную точку
						из центра Земли и плоскостью экватора.

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Широта

						Широту места можно определить с помощью таких
						астрономических инструментов, как секстант или 
						гномон. Также можно воспользоваться системами
						GPS, ГЛОНАСС и др.
						
						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Долгота

						Долгота - это двугранный угол $\lambda$ между 
						плоскостью меридиана, проходящего через данную точку,
						и плоскостью начального нулевого меридиана, от которого
						ведется отсчет долготы. Долготу от $0^\circ$ до $180^\circ$ к
						востоку от нулевого меридиана называют восточной, к западу -
						западной. Восточные долготы принято считать положительными,
						западные - отрицательными.
						
						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Долгота

						Выбор нулевого меридиана произволен и зависит
						только от соглашений. Сейчас за нулевой меридиан принят
						меридиан, проходящий рядом с обсерваторией в Гринвиче. 
						От долготы так же зависит местное солнечное время.
						
						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Формы записи географических координат

						Координаты (широта от $-90^\circ$ до $90^\circ$,
						долгота от $-180^\circ$ до $180^\circ$) могут
						записываться:

						
						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Формы записи географических координат

						- в градусах в виде десятичной дроби (
							современный вариант)
						- в градусах и минутах с десятичной дробью
						- в градусах, минутах и секундах с десятичной
							дробью (историческая форма записи)
						- предыдущие варианты с дополнительными буквами 
							(E, W, S, N)
						
						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Формы записи географических координат

						Форматы можно пересчитать по формуле:
						$1^\circ$ = $60'$, $1'$ = $60''$.
						
						Примеры:  
						$55,755831^\circ$  $37,617613^\circ$  
						$N55,755831^\circ$  $E37,617613^\circ$  
						$55^\circ45.35'$  $37^\circ37.06'$    
						$55^\circ45'20.9916''N$  $37^\circ37'3.6228''E$    

						Note:

					</script>
				</section>

				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						Величины
						-----------

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Радиан

						Радиан (от лат. radius луч) - угол соответствующий дуге,
						длина которой равна её радиусу. Единица измерения
						плоских углов в международной системе единиц (СИ)
						
						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Градус

						Градус (от лат. шаг, ступень) - обозначается. 
						Один полный оборот соответствует углу в $360^\circ$.
						В прямом угле $90^\circ$. В развернутом $180^\circ$.
						
						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Перевод величин

						$$
							\alpha^\circ = \alpha_\text{рад}\tfrac{180^\circ}{\pi}
						$$

						$$
							\alpha_\text{рад} = \tfrac{\pi}{180^\circ} \alpha_\text{рад}
						$$
						Note:

					</script>
				</section>

				<!-- 
					Для слайдов с программами используйте чистый HTML без доп аргументов в section
					Помните, что id элементов должны быть уникальными
					Проверьте, что Вы обращаетесь с элементов с id, которые существуют
				-->
				<section>
					<h3>Конвертер величин</h3>
					<!-- Поле для ввода конвертируемого значения -->
					<input type="text" name="" id="converter_value" 
					placeholder="Градусы или радианы">
					<!-- Выпадающее меню с вариантам конвертации -->
					<select id="converter_type">
						<option value="radian">Радиан</option>
						<option value="degree">Градус</option>
					</select>
					<!-- Кнопка конвертации -->
					<input type="button" id="converter_button" value="Конвертировать">
					<!-- Поле вывода -->
					<output id="converter_out"></output>
				</section>

				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						Тригонометрия
						-----------

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Тригонометрические функции

						Тригонометрические функции - элементарные функции,
						которые исторически возникли при рассмотрении
						прямоугольных треугольников и выражали зависимости длин
						сторон этих треугольников от прямых углов при гипотенузе.
						
						Note:

					</script>
				</section>

				<section>
					<h3>Тригонометрический круг</h3>
					<!-- Блок для рисования библиотекой plotly -->
					<div id="plot" style="height: 400px; margin-left:25%;"></div>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Тригонометрические функции

						$$
						\sin \alpha = \tfrac{y_b}{R}
						$$
						$$
						\cos \alpha = \tfrac{x_b}{R}
						$$
						$$
						\tg \alpha = 
							\tfrac{\sin \alpha}{\cos \alpha} =
							\tfrac{y_b}{x_b}
						$$
						$$
						\ctg \alpha = 
							\tfrac{\cos \alpha}{\sin \alpha} =
							\tfrac{x_b}{y_b}
						$$
						
						Note:

					</script>
				</section>

				<section>
					<h3>Таблица тригонометрических функций</h3>
					<!-- Сюда сгенерируем тригонометрическую таблицу -->
					<output id="table"></output>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Ортодромия
		
						Ортодромия (от греч. 
						$O\rho\theta\omicron\delta\rho\omicron\mu\omicron\varsigma$
						 прямой путь) в геометрии -
						кратчайшая линия между двумя точками на поверхности вращения.
						
						В картографии и навигации ортодромия - кратчайшее расстояние
						между двумя точками на поверхности Земли. 

						Частыми случаями ортодромии являются меридианы и экватор.
						
						Note:

					</script>
				</section>

				<section data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Рассчет ортодромии

						Длина ортодромии равна $D = l \cdot \delta $, где
						$
							\delta = \arccos(
								\sin \phi_1 \cdot \sin \phi_2 +
								\cos \phi_1 \cdot \cos \phi_2 \cdot
								\cos(\lambda_2 - \lambda_1)
							)
						$

						$\phi_1$ = широта начальной точки в градусах  
						$\phi_2$ = широта конечной точки в градусах  
						$\lambda_1$ = долгота начальной точки в градусах  
						$\lambda_2$ = долгота конечной точки в градусах  
						$l$ = длина дуги меридиана небесного тела
						Note:

					</script>
				</section>

				<section>
					<h3>Рассчет ортодромии</h3>
					<div>
						<!-- Поля для ввода конвертируемого значения широты и долготы точки А-->
						<label>Широта А
							<input type="text" id="latA">
						</label> <br>
						<label>Долгота А
							<input type="text" id="lonA">
						</label>
					</div>
					<div>
						<!-- Поля для ввода конвертируемого значения широты и долготы точки B-->
						<label>Широта B
							<input type="text" id="latB">
						</label> <br>
						<label>Долгота B
							<input type="text" id="lonB">
						</label>
					</div>
					<div>
						<!-- Кнопка для расчета -->
						<input id="ortodroma" type="button" value="Посчитать">
					</div>
					<!-- Вывод результата -->
					<output id="ortodroma_out"></output>
				</section>

				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						Игры
						----

						
						Note:

					</script>
				</section>

				<section>
					<h3>Игра 1. Города классические</h3>
					<!-- Кнопка начала игры -->
					<div id="game1_button_start" class="show">
						<input type="button" value="Начать игру" id="game1_start">
					</div>
					<!-- Игровое поле -->
					<div id="game1_area" class="hide">
						<!-- Лейбл для показа первой буквы города -->
						<label for="game1_town">Ваш город:</label>
						<!-- Поле для ввода города -->
						<input type="text" id="game1_town" >
						<!-- Кнопка для отправки города на сервер -->
						<input type="button" id="game1_set_result" value="Отправить город">
						<!-- Текущая информация об игре -->
						<output id="game1_town2"></output>
					</div>
					<!-- Карта для показа меток -->
					<div class="map" id="game1_map"></div>
					<aside class="note">
						Классическая игра в города.
						Правила игры: Вы должны ввести название города, которое начинается на 
						последнюю букву предыдущего города.
					</aside>
				</section>

				<section>
					<h3>Игра 2. Города на расстояние</h3>
					<!-- Кнопка начала игры -->
					<div id="game2_button_start" class="show">
						<input type="button" value="Начать игру" id="game2_start">
					</div>
					<!-- Игровое поле -->
					<div id="game2_area" class="hide">
						<!-- Лейбл для показа первой буквы города -->
						<label for="game2_town">Ваш город:</label>
						<!-- Поле для ввода города -->
						<input type="text" id="game2_town" >
						<!-- Кнопка для отправки города на сервер -->
						<input type="button" id="game2_set_result" value="Отправить город">
						<!-- Текущая информация об игре -->
						<output id="game2_town2"></output>
					</div>
					<!-- Текущий счет игры. -->
					<div id="game2_score" class="hide">
						<span>Счет: </span>
						<span id="game2_score"></span>
					</div>
					<!-- Карта для показа меток -->
					<div class="map" id="game2_map"></div>
				</section>

				<section>
					<h3>Игра 3. Города на расстояние. Многопользовательская</h3>
					<!-- Поле начала игры -->
					<div id="game3_button_start" class="show">
						<label for="game3_name"></label>
						<!-- Поле для ввода имени играющего -->
						<input type="text" id="game3_name" value="Fox">
						<!-- Кнопка начала игры -->
						<input type="button" value="Начать игру" id="game3_start">
					</div>
					<!-- Блок для информации об ожидании игрока -->
					<div id="game3_waiting">
					</div>
					<!-- Игровое поле -->
					<div id="game3_area" class="hide">
						<!-- Лейбл для показа первой буквы города -->
						<label for="game3_town">Ваш город:</label>
						<!-- Поле для ввода города -->
						<input type="text" id="game3_town" >
						<!-- Кнопка для отправки города на сервер -->
						<input type="button" id="game3_set_result" value="Отправить город">
						<!-- Текущая информация об игре -->
						<output id="game3_town2"></output>
					</div>
					<!-- Текущий счет игры. -->
					<div id="game3_score" class="hide">
						<span>Счет: </span>
						<span id="game3_score"></span>
					</div>
					<!-- Карта для показа меток -->
					<div class="map" id="game3_map"></div>
				</section>

				<!-- Блок для исходных кодов-->
				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						Исходный код программ
						----

						Note:

					</script>
				</section>

				<!-- Вставляйте с помощью трех обратных апострофов  -->
				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						### Вычисление ортодромы
						```
						function ortodroma (latA, lonA, latB, lonB) {
							return 6372795 * Math.acos (
								Math.cos(deg2rad(latB)) * Math.cos(deg2rad(latA)) *
								Math.cos(deg2rad(lonA) - deg2rad(lonB)) + 
								Math.sin(deg2rad(latB)) * Math.sin(deg2rad(latA))
							);
						}
						```
						Note:

					</script>
				</section>

				<section class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						Веселые картинки
						----

						Note:

					</script>
				</section>
		
				
				<section data-menu-title="Заключительный слайд" class="center" data-markdown  data-separator-notes="^Note:">
					<script type="text/template">
						Спасибо за внимание
					</script>
				</section>

			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<!-- Вставляем стандартный плагин математики -->
		<script src="plugin/math/math.js"></script>
		
		<!-- Все библиотеки ниже скачиваются отдельно со своих официальных сайтов-->
		<!-- Математические библиотеки math.js и algebrite  -->
		<script src="js/algebrite.bundle-for-browser.js"></script>
		<script src="js/math.js"></script>
		<!-- Библиотека для рисования -->
		<script src="js/plotly-2.6.3.min.js"></script>
		<!-- Библиотека географических карт, вставляется по инструкции на официальном сайте -->
		<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
		<!-- Библиотека websocket игрового сервера -->
		<script src="https://city.9pr.ru/socket.io/socket.io.js"></script>

		<script>
			Reveal.initialize({
				hash: true, // данная настройка позволит после перезагрузки презентации вернутся к последнему открытому слайду
				center: false, //Привязываем вверх слайда к верху экрана
				slideNumber: true, //Показываем номер страницы
				controls: true, //Разрешаем управлять презентацией с помощью клавиатуры
				//Так как меню старый плагин, загружаем его старым методом
				dependencies: [
					{
						src: 'plugin/menu/menu.js'
					},
				],
				//Настраиваем меню, показывая номер слайда и маркер пройденных слайдов
				menu : {
					numbers: true,
					markers: true, 
				},
				//Дополнительно подключим KaTeX
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX]
			});
		</script>
		<script>
			//Переменные слоя карты, содержающие метки городов
			let markersLayer;
			let markersLayer2;
			let markersLayer3;
			//Массив меток городов
			let markers;
			let markers2;
			let markers3 = [];
			//Копия последнего массива меток для отката назад, если понадобится
			let markersCopy = [];
			//Счет игры
			let score2 = [0,0];
			let score3 = [0,0];
			//Последние координаты для подсчета счета игры
			let lastCoord2 = [];
			let lastCoord3 = [];
			//Имя играющего
			let name;
			//Имя противника
			let opponent;
			//Метка кто ходит первым, а кто вторым
			let whoGo;
			//Номер игровой комнаты
			let room;
			//Ссылка на подключение сокета
			let socket;
			//Множество городов для третьей игры
			let game3Set;

			//Запускаем наши программы только после того, как вся страница полностью прогрузится
			window.onload = () => {

				//Костыль для совместной работы меню и input
				//Имеется баг, при введение мягкого знака в поле вода
				//включается меню. Этим костылем мы отменяем это действие
				document.addEventListener('keydown', (event) => {
					//Так как код клавиши Ь - 77, а тег INPUT, то сравниваем
					//и закрываем меню при соблюдение условий
					if (event.keyCode === 77 && ['INPUT'].indexOf(
						event.target.tagName
					) > -1) {
						RevealMenu.toggle();
					}
				});

				//Рисуем круг
				let layout = {
					//Заголовок
					title: 'Тригонометрический круг',
					//Ограничение координатной плоскости
					xaxis: {
						range: [-1.5, 1.5],
					},
					yaxis: {
						range: [-1.5, 1.5],
					},
					//Ширина и высота координатной плоскости
					width: 500,
					height: 500,
					//Графики
					shapes: [
						{
							// окружность задается с помощью описаного около него прямоугольника
							// по координатам левой нижнего и правого верхнего угла
							type: 'circle',
							xref: 'x',
							yref: 'y',
							x0: -1,
							y0: -1,
							x1: 1,
							y1: 1,
							line: {
								color: 'rgba(50, 171, 96, 1)',
							},
						},
						{
							// Отрезки задаются с помощью координат концом. Координаты считаются по теореме Пифагора
							type: 'line',
							x0: 0,
							y0: 0,
							x1: Math.sqrt(.51),
							y1: .7,
							line: {
								color: 'blue',
								width: 2.5,
							},
						},
						{
							type: 'line',
							x0: 0,
							y0: .7,
							x1: Math.sqrt(.51),
							y1: .7,
							line: {
								color: 'red',
								width: 2.5,
							},
						},
						{
							type: 'line',
							x0: Math.sqrt(.51),
							y0: 0,
							x1: Math.sqrt(.51),
							y1: .7,
							line: {
								color: 'red',
								width: 2.5,
							},
						},
					],
					//Подписи графиков
					annotations: [
						{
							x: 0,
							y: .7,
							xref: 'x',
							yref: 'y',
							text: 'Yb',
							arrowhead:7, 
							showarrow: true,
							ay: 0,
							ax: -20,
						},
						{
							x: Math.sqrt(.51),
							y: 0,
							xref: 'x',
							yref: 'y',
							text: 'Xb',
							arrowhead:7, 
							showarrow: true,
							ay: 20,
							ax: 0,
						},
						{
							x:  Math.sqrt(.51),
							y: .7,
							text: 'B',
						},
						{
							x: -.1,
							y: -.1,
							text: '0',
							ax: 0,
							ay: 0,
						},
					],
				};
				//Рисуем график, 1 аргумент id блока, в который рисуем
				//2 аргумент оставим пустой массив, 3 аргумент объект с данными
				Plotly.newPlot('plot', [], layout);

				//Рассчет ортодромы
				//Программируем кнопка подсчета
				document.querySelector('#ortodroma').onclick = (e) => {
					//Считываем координаты точек
					let latA = document.querySelector('#latA').value;
					let latB = document.querySelector('#latB').value;
					let lonA = document.querySelector('#lonA').value;
					let lonB = document.querySelector('#lonB').value;
					//Делаем проверку на пустоту полей. Если хотя бы 1 не заполнено, то выводим ошибку
					if (latA === '' || latB === '' || lonA === '' || lonB === '') {
						alert('Не все поля заполнены');
					}
					//Ставим ограничение по максимальным значениям долготы и широты
					if (
						+latA < -90 || +latA > 90 ||
						+latB < -90 || +latB > 90 ||
						+lonA < -180 || +lonA > 180 ||
						+lonB < -180 || +lonB > 180
					) {
						alert('Неверное значение одного из полей');
					}
					//Считаем ортодрому между 2 точками
					let result = ortodroma(+latA, +lonA, +latB, +lonB);
					//Выводим результат в специальное поле
					document.querySelector('#ortodroma_out').innerHTML = result;
				}

				// Конвертер величин
				document.querySelector('#converter_button').onclick = () => {
					//Считываем данные из формы
					let converterValue = document.querySelector('#converter_value');
					let converterType = document.querySelector('#converter_type');
					let converterOut = document.querySelector('#converter_out');
					//Делаем проверку на пустоту
					if (converterValue.value === '') {
						alert('Поле не заполнено');
					}
					//Получаем значение выпадающего меню
					// 0 - это радианы
					// 1 - это градусы
					let currentType = +converterType.options.selectedIndex;
					if (currentType === 0) {
						//Формируем формулы перевода и рендерим катехом
						result = katex.renderToString( 
							math.evaluate('180 * ' + converterValue.value + '/ pi') + 
							'^{\\circ}');
					} else if (currentType === 1) {
						//Формируем формулы перевода и рендерим катехом
						result = katex.renderToString( math.simplify(converterValue.value + 
						' * pi / 180').toTex());
					}
					//Записываем результат в поле вывода
					converterOut.innerHTML = result;
				}

				//Таблица тригонометрических функций
				//Массив значений для таблицы
				let values = ['0', 'pi/6', 'pi/4', 'pi/3', 'pi/2', 
					'pi', '3pi/2', '2pi',	
				];
				//Массив функций для таблицы
				let functions = ['sin', 'cos', 'tan'];
				//Запускаем функцию генерирующую таблицу
				trigonometry(values, functions);


				// Игра 1
				//Программируем клик по кнопке старт
				document.querySelector('#game1_start').onclick = () => {
					//Скрываем саму кнопку
					document.querySelector('#game1_start').style.display = 'none';
					//Отобразим игровое поле
					document.querySelector('#game1_area').style.display = 'block';
					//Инициализируем карту
					map_game1 = L.map('game1_map').setView([51.478, 0, 0], 13);
					//Подгрузим тайлы карты и добавим их на карту
					L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png')
					.addTo(map_game1);
				}
				//Что бы города не повторялись используем множество. так как в нем все элементы уникальны
				const game1Set = new Set();
				//Програмируем клик отправки города
				document.querySelector('#game1_set_result').onclick = async () => {
					//получаем город из поля
					let town = document.querySelector('#game1_town').value;
					//Делаем проверку, что этот город еще не был введен
					if (game1Set.has(town)) {
						alert('Данный город уже был');
					} else {
						//Если такого города нет, то добавим его в множество
						game1Set.add(town);
						//делаем запрос к игровому серверу о получении информации о введенном городе
						let response = await fetch(`https://city.9pr.ru/city/${town}`);
						//получаем текст сообщения
						let text = await response.text();
						//так как ответ приходит в формате JSON, предварительно отпарсим его
						text = JSON.parse(text);
						//Делаем проверку на ошибки, если поле с ошибкой не пусто, то оповещаем, если нет, идем дальше
						if (text.error === undefined || text.error === null) {
							//делаем проверку на существование города. если город существует, то идем дальше.
							if (text.no === undefined) {
								//Получаем последнюю букву города, чтобы следующий начинался на предыдущую
								let lastletter = lastLetter(town);
								//Предварительно очистим слой с метками
								if (markersLayer !== undefined) {
									markersLayer.clearLayers();
								}
								//Обнулим массив меток
								markers = [];
								//Добавим метку введенного пользователем города
								markers.push(
									L.marker([text.latitude, text.longitude]).
									bindPopup(text.city)
								);
								//делаем запрос к игровому серверу о получении города на последнюю букву введенного города
								response = await fetch(`https://city.9pr.ru/lastletter/${lastletter}`);
								//получаем текст сообщения
								text = await response.text();
								//так как ответ приходит в формате JSON, предварительно отпарсим его
								text = JSON.parse(text);
								//Делаем проверку на ошибки, если поле с ошибкой не пусто, то оповещаем, если нет, идем дальше
								if (text.error === undefined || text.error === null) {
									//Добавим город в множество, чтобы не повторялся и этот город
									game1Set.add(text.city);
									//Добавим и его в массив меток для карты
									markers.push(
										L.marker([text.latitude, text.longitude]).
										bindPopup(text.city)
									);
									//Покажем информацию об обоих городах
									document.querySelector('#game1_town2').innerHTML = `
										<div>Ваш город: ${town}. <br> Город противника
											${text.city}</div>
									`;
									//Для удобства первую букву нового города покажем в лейбле 
									document.querySelector('label[for="game1_town"]').textContent = `
											Ваш город на ${lastLetter(text.city).toUpperCase()}:
									`;
									//а так же сразу вставим её в поле ввода
									document.querySelector('#game1_town').value = 
										lastLetter(text.city).toUpperCase();
									//Добавим метки на карту
									markersLayer = L.featureGroup(markers).addTo(map_game1);
									//Передвинем карту, чтобы обе метки оказались в зоне видимости
									map_game1.fitBounds(markersLayer.getBounds());
								} else {
									//Выведем ошибку
									document.querySelector('#game1_town1').innerHTML =
									'Произошла ошибка, игра окончена.';
									console.log('Ошибка: ', text.error);
								}
							} else {
								//Выведем ошибку
								alert('Такого города не существует');
							}
						} else {
							//Выведем ошибку
							document.querySelector('#game1_town1').innerHTML =
							'Произошла ошибка, игра окончена.';
							console.log('Ошибка: ', text.error);
						}
					}
				}

				// Игра 2
				//Программируем клик по кнопке старт
				document.querySelector('#game2_start').onclick = () => {
					//Скрываем саму кнопку
					document.querySelector('#game2_start').style.display = 'none';
					//Отобразим игровое поле
					document.querySelector('#game2_area').style.display = 'block';
					//Отобразим счет и покажем нулевой счет
					document.querySelector('#game2_score').style.display = 'block';
					document.querySelector('#game2_score').innerHTML = 'Игрок 0 : 0 Компьютер';
					//Инициализируем карту
					map_game2 = L.map('game2_map').setView([51.478, 0, 0], 13);
					//Подгрузим тайлы карты и добавим их на карту
					L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png')
					.addTo(map_game2);
					//Обнуляем переменную счета на начало игры
					score2 = [0, 0];
				}
				//Что бы города не повторялись используем множество. так как в нем все элементы уникальны
				const game2Set = new Set();
				//Програмируем клик отправки города
				document.querySelector('#game2_set_result').onclick = async () => {
					//получаем город из поля
					let town = document.querySelector('#game2_town').value;
					//Делаем проверку, что этот город еще не был введен
					if (game2Set.has(town)) {
						alert('Данный город уже был');
					} else {
						//Если такого города нет, то добавим его в множество
						game2Set.add(town);
						//делаем запрос к игровому серверу о получении информации о введенном городе
						let response = await fetch(`https://city.9pr.ru/city/${town}`);
						//получаем текст сообщения
						let text = await response.text();
						//так как ответ приходит в формате JSON, предварительно отпарсим его
						text = JSON.parse(text);
						//Делаем проверку на ошибки, если поле с ошибкой не пусто, то оповещаем, если нет, идем дальше
						if (text.error === undefined || text.error === null) {
							//делаем проверку на существование города. если город существует, то идем дальше.
							if (text.no === undefined) {
								//Получаем последнюю букву города, чтобы следующий начинался на предыдущую
								let lastletter = lastLetter(town);
								//Предварительно очистим слой с метками
								if (markersLayer2 !== undefined) {
									markersLayer2.clearLayers();
								}
								//Обнулим массив меток
								markers2 = [];
								//Если в переменной последних координат есть запись, то считаем ортодрому
								//между Вашим городом и городом компьютера. Отбрасываем дробную часть и записываем
								//в счет игрока
								if (lastCoord2.length === 2) {
									score2[0] += Math.floor(
										ortodroma(
											text.latitude, text.longitude,
											lastCoord2[0], lastCoord2[1]
										)
									);
								}
								//обновим переменную последних координат
								lastCoord2 = [text.latitude, text.longitude];
								//Добавим метку введенного пользователем города
								markers2.push(
									L.marker([text.latitude, text.longitude]).
									bindPopup(text.city)
								);
								//делаем запрос к игровому серверу о получении города на последнюю букву введенного города
								response = await fetch(`https://city.9pr.ru/lastletter/${lastletter}`);
								//получаем текст сообщения
								text = await response.text();
								//так как ответ приходит в формате JSON, предварительно отпарсим его
								text = JSON.parse(text);
								//Делаем проверку на ошибки, если поле с ошибкой не пусто, то оповещаем, если нет, идем дальше
								if (text.error === undefined || text.error === null) {
									//Добавим город в множество, чтобы не повторялся и этот город
									game2Set.add(text.city);
									//Если в переменной последних координат есть запись, то считаем ортодрому
									//между Вашим городом и городом компьютера. Отбрасываем дробную часть и записываем
									//в счет компьютера
									if (lastCoord2.length === 2) {
										score2[1] += Math.floor(
											ortodroma(
												text.latitude, text.longitude,
												lastCoord2[0], lastCoord2[1]
											)
										);
									}
									//обновим переменную последних координат
									lastCoord2 = [text.latitude, text.longitude];
									//Добавим и его в массив меток для карты
									markers2.push(
										L.marker([text.latitude, text.longitude]).
										bindPopup(text.city)
									);
									//Покажем информацию об обоих городах
									document.querySelector('#game2_town2').innerHTML = `
										<div>Ваш город: ${town}. <br> Город противника
											${text.city}</div>
									`;
									//Для удобства первую букву нового города покажем в лейбле 
									document.querySelector('label[for="game2_town"]').textContent = `
											Ваш город на ${lastLetter(text.city).toUpperCase()}:
									`;
									//а так же сразу вставим её в поле ввода
									document.querySelector('#game2_town').value = 
										lastLetter(text.city).toUpperCase();
									//Добавим метки на карту
									markersLayer2 = L.featureGroup(markers2).addTo(map_game2);
									//Передвинем карту, чтобы обе метки оказались в зоне видимости
									map_game2.fitBounds(markersLayer2.getBounds());
									//Выведем счет на экран по принципу. Разница между ведущим игроком
									// и отстающим у ведущего и 0 у отстающего всегда. Это сделано, чтобы 
									// не перегружать экран большими числами
									document.querySelector('#game2_score').innerHTML =
									score2[0] >= score2[1] ?
									`<b>Игрок</b> ${score2[0]-score2[1]} : 0 Компьютер` :
									`Игрок 0 : ${score2[1]-score2[0]} Компьютер`
								} else {
									//Выведем ошибку
									document.querySelector('#game2_town2').innerHTML =
									'Произошла ошибка, игра окончена.';
									console.log('Ошибка: ', text.error);
								}
							} else {
								//Выведем ошибку
								alert('Такого города не существует');
							}
						} else {
							//Выведем ошибку
							document.querySelector('#game2_town2').innerHTML =
							'Произошла ошибка, игра окончена.';
							console.log('Ошибка: ', text.error);
						}
					}
				}

				//3игра
				//Что бы города не повторялись используем множество. так как в нем все элементы уникальны
				game3Set = new Set();
				//Программируем клик по кнопке старт
				document.querySelector('#game3_start').onclick = () => {
					//Если сокеты игрового сервера не прогрузились, то играть бессмысленно, выдаем ошибку.
					//В противном случае подключаемся к игровому серверу.
					if (typeof io !== 'undefined') {
						//Подключаемся к сокетам игрового сервера
						socket = io("https://city.9pr.ru");
						//Все события сокетов проводим внутри этого блока
						socket.on("connect", () => {
							//сокет ожидания игрока. Как только к игре кто-то присоеденился, то мы получим этот сокет
							socket.on('wait', (body) => {
								//получим id игровой комнаты, в которой идет игра
								room = body.room;
								//Обойдем всех игроков в комнате
								Object.keys(body.gamers).forEach(gamePlayer => {
									//когда найдем не себя, запустим процесс начала игры
									if (name !== gamePlayer) {
										//Запишем имя соперника
										opponent = gamePlayer;
										//Запишем порядок хода
										whoGo = body.gamers[gamePlayer][1];
										//Выводим на экран сообщение о том, кто присоеденился к игре
										document.querySelector('#game3_waiting').innerHTML = `К игре присоеденился: ${gamePlayer}. Ожидайте начала игры.`;
										//По таймауту отображаем игровое поле. Таймаут нужен для предотвращения ошибок подключения
										setTimeout(() => {
											//Скрываем кнопки начала игры и сообщения о присоединения к игре
											document.querySelector('#game3_button_start').style.display = 'none';
											document.querySelector('#game3_area').style.display = 'none';
											document.querySelector('#game3_waiting').style.display = 'none';
											//Отображаем первоначальный счет игры с именами игроками
											document.querySelector('#game3_score').style.display = 'block';
											document.querySelector('#game3_score').innerHTML = `"${name}" 0 : 0 "${opponent}"`;
											//Инициализируем карту
											map_game3 = L.map('game3_map').setView([51.478, 0, 0], 13);
											//Заполняем её тайлами
											L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map_game3);
											//Обнуляем счет игры
											score3 = [0,0];
											//Второй игрок должен подождать пока ход сделает первый игрок, поэтому выводим ему блокирующее сообщение
											if (whoGo == 1) {
												document.querySelector('#game3_waiting').style.display = 'block';
												document.querySelector('#game3_waiting').innerHTML = 'Подождите, пока Ваш оппонент сделает ход.';
											//Первому игроку выводим игровое поле
											} else {
												document.querySelector('#game3_area').style.display = 'block';
											}
											//Таймаут делаем 3 секунды
										}, 3000);
									}
								});
							});
							//Событие на получения города, отправленного соперником
							socket.on('getCity', (body) => {
								//Получаем счет
								score3 = body.score;
								//Расписываем счет в поле счета по принципу. Ведущий - разность счета двух игроков. Отстающий - ноль.
								//При ничьей 0:0. Это нужно для уменьшения количество символов в счете. Иначе поле начинает
								//очень быстро заполняться и выходить за пределы экрана
								//Конструкция (whoGo+1)%2 позволяет получить в результате или 0 или 1, что нам и нужно
								if (score3[whoGo] > score3[(whoGo+1)%2]) {
									document.querySelector('#game3_score').innerHTML = 
										`<p><b>"${name}" ${score3[whoGo]}</b> : ${score3[(whoGo+1)%2]} "${opponent}"</p>`;
								} else if (score3[whoGo] < score3[(whoGo+1)%2]) {
									document.querySelector('#game3_score').innerHTML = 
										`<p>"${name}" ${score3[whoGo]} : <b>${score3[(whoGo+1)%2]} "${opponent}"</b></p>`;
								} else {
									document.querySelector('#game3_score').innerHTML = 
										`<p>"${name}" 0 : 0 "${opponent}"</p>`;
								}
								//Если имя в событие равно имени опонента, то значит город ввел он. Начинает менять игровое поле.
								if (body.name === opponent) {
									//Предварительно очистим слой меток на карте. 
									if (markersLayer3 !== undefined) {
										markersLayer3.clearLayers();
									}
									//Добавим город в множество неповторений, чтобы город нельзя было ввести повторно
									game3Set.add(body.city.city);
									//Обновим массив последних координат
									lastCoord3 = [body.city.latitude, body.city.longitude];
									//Добавим метку в массив меток
									markers3.push(L.marker([body.city.latitude, body.city.longitude]).bindPopup(body.city.city));
									//Если меток стало 3, то убираем 1 в очереди. Так как нам всегда нужно иметь не больше 2 меток
									if (markers3.length > 2) {
										markers3.shift();
									}
									//Добавим метки на карту
									markersLayer3 = L.featureGroup(markers3).addTo(map_game3);
									//Позиционируем карту
									map_game3.fitBounds(markersLayer3.getBounds());
									//Отобразим игровую область
									document.querySelector('#game3_area').style.display = 'block';
									//Скроем сообщения об ожидании хода
									document.querySelector('#game3_waiting').style.display = 'none';
									//Получим последнюю букву имени
									let lastletter2 = lastLetter(body.city.city);
									//Для удобства первую букву города, который придется ввести игроку выведем в label поля ввода
									//, а также в само поле ввода
									document.querySelector('#game3_town').value = lastletter2.toUpperCase();
									document.querySelector('label[for="game3_town"]').textContent = `Ваш город на ${lastletter2.toUpperCase()}:`;
								}
							});
							//Если пришло сообщение об ошибке
							socket.on('error', (body) => {
								//Первый тип ошибки сможет присылаться до начала игры. Например, когда имя уже занято
								if (body.type === 'pre_game') {
									//Выведем ошибку в alert и вернем поле ввода имени на место
									document.querySelector('#game3_start').style.display = 'inline';
									document.querySelector('#game3_waiting').style.display = 'none';
									alert(body.text);
								//Второй тип ошибки сможет присылаться только во время самой игры. 
								//Например нарушены правила игры
								} else if (body.type === 'in_game') {
									//Выведем в alert сообщение об ошибки и востановим игровое поле
									//в состояние, как было до нарушения игры
									document.querySelector('#game3_area').style.display = 'inline';
									document.querySelector('#game3_waiting').style.display = 'none';
									if (markersLayer3 !== undefined) {
										markersLayer3.clearLayers();
									}
									markersLayer3 = L.featureGroup(markersCopy).addTo(map_game3);
									map_game3.fitBounds(markersLayer3.getBounds());
									game3Set.delete($('#game3_town').value);
									alert(body.text);
								}
							});
							//Сообщение о том, что один из игроков покинул игру
							socket.on('exit', (data) => {
								//Скроем игровую область, карту и счет.
								document.querySelector('#game3_area').style.display = 'none';
								document.querySelector('#game3_score').style.display = 'none';
								document.querySelector('#game3_map').style.display = 'none';
								//Выведем на экран последний счет игры с сообщением о том, что 
								//игра закончена по причине выхода из неё второго игрока
								document.querySelector('#game3_waiting').style.display = 'block';
								document.querySelector('#game3_waiting').innerHTML = `
									<p>К сожалению ${data.name} покинул игру. Игра окончена.</p>
									<p>Счет игры "${name}" ${score3[whoGo]} : ${score3[(whoGo+1)%2]} "${opponent}"</p>
								`;
								document.querySelector('#game3_start').style.display = 'block';
								game3Set.clear();
							});
							//Сообщение о том, что соединение с сервером пропало
							socket.on("disconnect", (reason) => {
								//Скроем игровую область, карту и счет.
								document.querySelector('#game3_area').style.display = 'none';
								document.querySelector('#game3_score').style.display = 'none';
								document.querySelector('#game3_map').style.display = 'none';
								//Выведем на экран последний счет игры с сообщением о том, что 
								//игра закончена по причине выхода из неё второго игрока
								document.querySelector('#game3_waiting').style.display = 'block';
								document.querySelector('#game3_waiting').innerHTML = `
									<p>К сожалению соединение с сервером потеряно. Игра окончена.</p>
									<p>Счет игры "${name}" ${score3[whoGo]} : ${score3[(whoGo+1)%2]} "${opponent}"</p>
									Для старта новой игры - обновите страницу.`;
								game3Set.clear();
							});
						});

						//При нажатие на кнопку старт скрываем кнопку старт 
						document.querySelector('#game3_start').style.display = 'none';
						//Выводим блок с ожиданием игрока
						document.querySelector('#game3_waiting').style.display = 'block';
						//Имя игрока сразу сохраним себе
						name = document.querySelector('#game3_name').value;
						//Выводим текст Ожидайте игрока на экран
						document.querySelector('#game3_waiting').innerHTML = `<p>Ожидайте игрока</p>`;
						//отправим серверу сообщение о желание начать игру и имя игрока
						socket.emit('start', name);
					} else {
						//Вслучае если сервер недоступен, то выводим это сообщение
						alert('Соединение с сервером отсутствует, попробуйте начать игру позднее, перезагрузив страницу.');
					}
				};
				//Программируем клик для отправки города на сервер
				document.querySelector('#game3_set_result').onclick = async () => {
					//Получаем город из поля ввода
					let town = document.querySelector('#game3_town').value;
					//Предваритально проверем, был ли этот город уже введен ранее
					if (game3Set.has(town)) {
						alert('Данный город уже был');
					} else {
						//Добавим его в множество городов, чтобы нельзя было его ввести повторно
						game3Set.add(town);
						//делаем запрос к игровому серверу о получении города на последнюю букву введенного города
						let response = await fetch(`https://city.9pr.ru/city/${town}`);
						//получаем текст сообщения
						let text = await response.text();
						//так как ответ приходит в формате JSON, предварительно отпарсим его
						text = JSON.parse(text);
						//Делаем проверку на ошибки, если поле с ошибкой не пусто, то оповещаем, если нет, идем дальше
						if (text.error === undefined || text.error === null) {
							//Если город существует, то идем по этому блоку
							if (text.no === undefined) {
								//Предварительно очищаем слой карты
								if (markersLayer3 !== undefined) {
									markersLayer3.clearLayers();
								}
								//Если переменная последних координат непуста, то считаем расстояние и плюсуем к счету в игре
								//При этом отбросим дробную часть. Оставляем только целые метры.
								if (lastCoord3.length === 2) {
									score3[whoGo] += Math.floor(ortodroma (text.latitude, text.longitude, lastCoord3[0], lastCoord3[1]));
								}
								//Обновим координаты последнего города
								lastCoord3 = [text.latitude, text.longitude];
								//Делаем копию меток, чтобы можно было потом откатить назад, вслучае нарушения правил
								markersCopy = Object.values(markers3);
								//Добавим метку в массив, и когда меток станет 3, то очистим самую старую из них
								markers3.push(L.marker([text.latitude, text.longitude]).bindPopup(text.city));
								if (markers3.length > 2) {
									markers3.shift();
								}
								//Добавим метки на карту
								markersLayer3 = L.featureGroup(markers3).addTo(map_game3);
								//Позиционирование карты
								map_game3.fitBounds(markersLayer3.getBounds());
								//Отправим сообщение серверу о текущем счете, игроке, комнате и городе
								socket.emit('sendCity', {
									score: score3,
									name,
									room,
									city: text,
								});
								//Скрываем игровое поле и выводим сообщение об ожидание хода следующим игроком
								document.querySelector('#game3_button_start').style.display = 'none';
								document.querySelector('#game3_area').style.display = 'none';
								document.querySelector('#game3_waiting').innerHTML = 'Подождите, пока Ваш оппонент сделает ход.';
								document.querySelector('#game3_waiting').style.display = 'block';
							} else {
								//Если введенного города не существует, то введем соответствующее сообщение
								alert(text.no);
							}
						//Если произошла какая-то ошибка сервера, из-за которого нельзя продолжать играть или даже начинать
						//выводим сообщение о том, что игра окончена
						} else {
							document.querySelector('#game3_town2').innerHTML = `
								<p>Произошла ошибка, игра окончена.</p>
							`;
							document.querySelector('#game3_set_result').style.display = 'none';
							console.log('Ошибка: ', text.error);
						}
					}
				};
			}

			//Функция рассчета расстояния между 2 точками на географической плоскости
			function ortodroma (latA, lonA, latB, lonB) {
				return 6372795 * Math.acos (
					Math.cos(deg2rad(latB)) * Math.cos(deg2rad(latA)) *
					Math.cos(deg2rad(lonA) - deg2rad(lonB)) + 
					Math.sin(deg2rad(latB)) * Math.sin(deg2rad(latA))
				);
			}

			//Функция конвертирования градусов в радианы по формуле
			function deg2rad (degree) {
				return Math.PI * degree / 180;
			}

			//Функция генерации тригонометрической таблицы
			function trigonometry(values, functions) {
				//Начинаем собирать таблицу путем добавления тегов
				let table = '<table><thead>';
					table += '<tr><td>Радианы</td>';
					//В первой строке выводим в цикле значения углов 
					for (let value of values) {
						//С помощью катеха выводим эти значения красиво
						table += `<td>${katex.renderToString(
							Algebrite.simplify(value).toLatexString())}</td>`;
					}
					table += '</tr><thead><tbody>';
					//В цикле обходим построчно тригонометрические функции
					for (let func of functions) {
						//В первую колонку с помощью катеха красиво выводим эти функции
						table += `<tr><td>${func}${
							katex.renderToString('\\alpha')}</td>`;
							//В цикле обходим все колонки, подставляя аргумент функций
							//И с помощью катеха выводим в красивом виде значение функции  
							for (value of values) {
								//С помощью Algebrite получим результат
								let result = Algebrite.simplify(func+'('+value+')');
								//После первого вывода выяснилось, что тангенс угла в 90 градусов
								//отображался выражением tg pi/2.
								//Методом научного тыка определили маркер отслеживания этих значений
								//и создали дополнительное условие, при котором вместо tg pi/2 выводим
								//бесконечность
								if (result.cons.car !== null &&
									result.cons.car.printname == 'tan') {
										table += `<td>${katex.renderToString(
											'\\infty'
										)}</td>`;
								} else {
									table += `<td>${katex.renderToString(
											result.toLatexString()
										)}</td>`;
								}
							}
					}
				table += '</tbody></table>';
				//Находим блок для вставки таблицы по его id и заполняем его нашей таблицей
				document.querySelector('#table').innerHTML = table;
			}

			function lastLetter (town) {
				let lastletter;
				//Обходим слово посимвольно с конца.
				for (let i = -1; i > -town.length; i--) {
					//Забираем текущую букву в цикле
					lastletter = town.substr(i, 1);
					//Если там нет ы,ь,ъ то возвращаем эту букву, иначе переходим 
					// к следующей букве с конца
					if (['ь','ъ','ы'].indexOf(lastletter) === -1) {
						break;
					}
				}
				return lastletter;
			}
		</script>
	</body>
</html>
